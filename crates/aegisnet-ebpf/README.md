# AegisNet eBPF 模块

## 技术亮点

### CO-RE（一次编译，多内核运行）实现
- 使用 Aya 的 BpfSkeleton 实现 CO-RE 技术，极大提高了 eBPF 程序的可移植性
- 通过 BTF（BPF Type Format）信息自动适配不同内核版本的数据结构差异
- 减少了针对不同内核版本的重复编译工作，降低了运维复杂度
- 支持从 5.4 到最新版本的 Linux 内核，覆盖主流云平台和企业环境

### Rust 语言安全特性与 eBPF 结合
- 通过 `#[aya_ebpf::program]` 宏定义 XDP/TC 程序，使代码更加简洁、易读
- 利用 Rust 的所有权模型和类型系统，在编译时消除内存安全问题
- 强类型系统确保 eBPF 映射（maps）访问的类型安全，减少运行时错误
- 零成本抽象，保证高性能的同时提供更好的开发体验

### 内核态日志记录系统
- `logging.rs` 模块实现了完整的内核态日志记录功能
- 使用 perf event array 高效传输日志从内核态到用户态
- 支持多种日志级别（Debug、Info、Warning、Error）
- 线程安全设计，支持多 CPU 并行记录日志
- 可配置的调试模式，方便在开发和生产环境中灵活切换

### 模块化钩子系统
- `hooks.rs` 模块清晰定义了 eBPF 程序的挂载点与钩子逻辑
- 支持 XDP、TC、Socket、Kprobe 等多种挂载点
- 统一的接口设计，简化了钩子的管理和操作
- 动态挂载和卸载功能，支持运行时调整监控点
- 接口抽象良好，提高了代码的可维护性和可扩展性

### SPIFFE 身份认证集成
- `auth.rs` 模块实现了基于 SPIFFE 的服务身份认证
- 与 SPIRE 无缝集成，支持 JWT-SVID 和 X.509-SVID 格式
- 在内核层面直接验证服务身份，实现真正的零信任架构
- 身份信息缓存机制，减少验证开销，提高性能

### Noise 协议加密通信
- `encryption.rs` 模块实现了基于 Noise 协议的网络通信加密
- 支持多种加密算法和密钥交换方式，适应不同安全级别需求
- 状态机设计，清晰区分握手阶段和传输阶段
- 线程安全实现，支持并发加解密操作

## 生产级设计

### 字节码管理与动态加载
- 分离 `bpf/` 目录专门存放 eBPF 字节码，支持动态加载
- 区分 `release/` 和 `debug/` 目录，针对不同环境优化
- 生产环境使用预编译的优化字节码，提高加载速度和运行效率
- 调试环境保留更多调试信息，方便问题排查

### Wasm 策略引擎
- `policy.rs` 模块集成 WasmEdge 运行时，实现基于 WebAssembly 的策略执行
- 集成 wasm2bpf 工具链将 Wasm 策略编译为 eBPF 字节码
- 支持策略的热更新，无需重启服务即可应用新策略
- 策略隔离执行，防止策略错误影响主程序稳定性
- 统一的策略接口，支持多语言编写策略（Rust、Go、AssemblyScript 等）

### 全面的测试覆盖
- `tests/` 目录包含单元测试、集成测试和性能测试
- 使用 `rstest` 和 `serial_test` 等现代测试框架
- 模拟内核环境进行 eBPF 程序测试，无需真实内核
- CI/CD 流程中自动运行测试，确保代码质量
- 性能基准测试，防止性能退化

### 高性能设计
- 批处理机制减少内核-用户态切换开销
- 使用 eBPF maps 高效共享数据
- 针对热路径代码优化，减少指令数和内存访问
- 利用 BPF 尾调用和程序链接，构建复杂处理管道
- 内存池和对象复用，减少动态分配

### 可观测性
- 内置丰富的性能指标收集
- 与 Prometheus 集成，支持监控告警
- 分布式追踪支持，与 OpenTelemetry 兼容
- 详细的审计日志，满足合规要求
- 故障注入接口，便于混沌测试

### 安全加固
- 最小权限原则设计，每个 eBPF 程序只请求必要的权限
- 敏感操作审计记录
- 防止权限提升和旁路攻击
- 定期安全扫描和漏洞检测
- 符合 SLSA 安全框架要求